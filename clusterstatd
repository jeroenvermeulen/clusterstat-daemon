#!/usr/bin/php -q
<?php
/*
### BEGIN INIT INFO
# Provides:           clusterstatd
# Required-Start:     $local_fs $remote_fs $network
# Required-Stop:      $local_fs $remote_fs $network
# Default-Start:      2 3 4 5
# Default-Stop:       0 1 6
# Short-Description:  ClusterStat Daemon
# Description:        This script collects status data for shared hosting.
### END INIT INFO

Enable init script on Debian and Ubuntu:

  sudo ln -s /usr/share/clusterstat-daemon/clusterstatd /etc/init.d/clusterstatd
  sudo update-rc.d clusterstatd defaults
  service clusterstatd start

Enable init script on Red Hat and CentOS:

  ln -s /usr/share/clusterstat-daemon/clusterstatd /etc/init.d/clusterstatd
  chkconfig clusterstatd on
  service clusterstatd start

*/
/**
 * @author Bas Peters       <bas.peters@nedstars.nl>
 * @author Jeroen Vermeulen <info@jeroenvermeulen.eu>
 */
try {
    // prepare environment
    require 'includes/bootstrap.php';

    // daemonize the script
    Daemonizer::daemonize();
    Log::info('Cluster statistics daemon started');

    // initialize webserver
    $webserver = new Webserver();
    $webserver->setCredentials(Config::get('http_username'), Config::get('http_password'));
    $webserver->setRoot(APP_ROOT . 'web');

    // initialize cluster statistics collection
    $stats = new ClusterStats();
    $procstats = new ProcStats();

    $stats->setProcStats( $procstats );

    $webserver->registerController('/', array($stats, 'homepage'));
    $webserver->registerController('/runtimestats.js', array($stats, 'getRuntimeStats'));
    $webserver->registerController('/procstats_json', array($procstats, 'getJsonProcStats'), 'application/json' );
    $webserver->registerController('/procstats_cacti', array($procstats, 'getCactiProcStats'), 'text/plain' );
    $webserver->registerController('/procstats_nagios', array($procstats, 'getNagiosProcStats'), 'text/plain' );
    $webserver->registerController('/procstats_detail_html', array($procstats, 'getProcStatsDetailHtml'), 'text/html' );

    // register timers
    $timer = new Timer();
    $timer->register(array('Log','rotate'), 30);

    $timer->register(array($procstats,'collectProcStats'), 1, true);
    $timer->register(array($procstats,'writeDatabase'), 300, false);

    // enter main application loop
    for(;;) {
        $webserver->handleClients(250000);

        // dispatch pending timer and system signals
        $timer->checkTimers();
        pcntl_signal_dispatch();
    }
} catch(Exception $e) {
    Log::error('Fatal '.get_class($e).': '.$e->getMessage());
    exit($e->getCode());
}
